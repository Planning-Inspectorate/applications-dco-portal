// @ts-nocheck
import assert from 'node:assert';
import { describe, it, mock } from 'node:test';
import { buildMalwareDetectionHandler } from './impl.ts';
import { WHITELIST_USER_ROLE_ID } from '@pins/dco-portal-database/src/seed/data-static.ts';

describe('malware detection function', () => {
	it('should save document scan result into db when message received', async () => {
		const mockDb = {
			document: {
				findFirst: mock.fn(() => ({
					id: 'document-id-1'
				})),
				update: mock.fn()
			}
		};
		const context = {
			log: mock.fn()
		};
		const eventGridEvent = {
			data: {
				blobUri: 'EN123456/draft-dco/draft-development-consent-order/test.pdf',
				scanResultType: 'No threats found'
			}
		};

		const handler = buildMalwareDetectionHandler({ db: mockDb });
		await handler(eventGridEvent, context);

		assert.strictEqual(mockDb.document.update.mock.calls.length, 1);
		assert.deepStrictEqual(mockDb.document.update.mock.calls[0].arguments[0], {
			where: {
				id: 'document-id-1'
			},
			data: {
				ScanResult: {
					connect: {
						id: 'scanned'
					}
				}
			}
		});

		assert.strictEqual(context.log.mock.callCount(), 1);
	});
	it('should send notification when message received', async () => {
		const mockDb = {
			document: {
				findFirst: mock.fn(() => ({
					id: 'document-id-1',
					uploaderEmail: 'test@email.com'
				})),
				update: mock.fn()
			},
			case: {
				findUnique: mock.fn(() => ({
					Whitelist: [
						{ email: 'admin1@email.com', userRoleId: WHITELIST_USER_ROLE_ID.ADMIN_USER },
						{ email: 'admin2@email.com', userRoleId: WHITELIST_USER_ROLE_ID.ADMIN_USER }
					]
				}))
			}
		};
		const mockNotify = {
			sendAntiVirusFailedNotification: mock.fn()
		};
		const context = {
			log: mock.fn()
		};
		const eventGridEvent = {
			data: {
				blobUri: 'EN123456/draft-dco/draft-development-consent-order/test.pdf',
				scanResultType: 'Malicious'
			}
		};

		const handler = buildMalwareDetectionHandler({ db: mockDb, notifyClient: mockNotify });
		await handler(eventGridEvent, context);

		assert.strictEqual(mockDb.document.update.mock.calls.length, 1);
		assert.deepStrictEqual(mockDb.document.update.mock.calls[0].arguments[0], {
			where: {
				id: 'document-id-1'
			},
			data: {
				ScanResult: {
					connect: {
						id: 'affected'
					}
				}
			}
		});

		assert.strictEqual(context.log.mock.callCount(), 1);

		assert.strictEqual(mockNotify.sendAntiVirusFailedNotification.mock.callCount(), 3);
		assert.deepStrictEqual(mockNotify.sendAntiVirusFailedNotification.mock.calls[0].arguments, [
			'admin1@email.com',
			{
				document_name: 'test.pdf',
				case_reference_number: 'EN123456',
				relevant_team_email_address: 'enquiries@planninginspectorate.gov.uk'
			}
		]);
		assert.deepStrictEqual(mockNotify.sendAntiVirusFailedNotification.mock.calls[1].arguments, [
			'admin2@email.com',
			{
				document_name: 'test.pdf',
				case_reference_number: 'EN123456',
				relevant_team_email_address: 'enquiries@planninginspectorate.gov.uk'
			}
		]);
		assert.deepStrictEqual(mockNotify.sendAntiVirusFailedNotification.mock.calls[2].arguments, [
			'test@email.com',
			{
				document_name: 'test.pdf',
				case_reference_number: 'EN123456',
				relevant_team_email_address: 'enquiries@planninginspectorate.gov.uk'
			}
		]);
	});
	it('should throw an error if event grid event data is not present', async () => {
		const handler = buildMalwareDetectionHandler({});
		await assert.rejects(() => handler({}, {}), {
			message: 'Received no input'
		});
	});
	it('should throw an error if info can not be obtained from blob uri', async () => {
		const eventGridEvent = {
			data: {
				blobUri: 'invalid-blob',
				scanResultType: 'Malicious'
			}
		};

		const handler = buildMalwareDetectionHandler({});
		await assert.rejects(() => handler(eventGridEvent, {}), {
			message: 'Not possible to extract info from blob with URI invalid-blob'
		});
	});
	it('should throw an error if scan result is not valid', async () => {
		const mockDb = {
			document: {
				findFirst: mock.fn(() => ({
					id: 'document-id-1'
				})),
				update: mock.fn()
			}
		};
		const eventGridEvent = {
			data: {
				blobUri: 'EN123456/draft-dco/draft-development-consent-order/test.pdf',
				scanResultType: 'Invalid'
			}
		};
		const context = {
			error: mock.fn()
		};

		const handler = buildMalwareDetectionHandler({ db: mockDb });
		await assert.rejects(() => handler(eventGridEvent, context), {
			message: "Error during malware detection function run: Could not map scan result 'Invalid' to a document status"
		});

		assert.strictEqual(context.error.mock.callCount(), 1);
	});
	it('should throw an error if document not found in db', async () => {
		const mockDb = {
			document: {
				findFirst: mock.fn()
			}
		};
		const eventGridEvent = {
			data: {
				blobUri: 'EN123456/draft-dco/draft-development-consent-order/test.pdf',
				scanResultType: 'Invalid'
			}
		};
		const context = {
			error: mock.fn()
		};

		const handler = buildMalwareDetectionHandler({ db: mockDb });
		await assert.rejects(() => handler(eventGridEvent, context), {
			message: 'Document not found in database with URI EN123456/draft-dco/draft-development-consent-order/test.pdf'
		});
	});
	it('should throw an error if issue encountered saving scan result to the database', async () => {
		const mockDb = {
			document: {
				findFirst: mock.fn(() => ({
					id: 'document-id-1'
				})),
				update: mock.fn(() => {
					throw new Error('Error', { code: 'E1' });
				})
			}
		};
		const eventGridEvent = {
			data: {
				blobUri: 'EN123456/draft-dco/draft-development-consent-order/test.pdf',
				scanResultType: 'Malicious'
			}
		};
		const context = {
			error: mock.fn()
		};

		const handler = buildMalwareDetectionHandler({ db: mockDb });
		await assert.rejects(() => handler(eventGridEvent, context), {
			message: 'Error during malware detection function run: Error'
		});
	});
});
