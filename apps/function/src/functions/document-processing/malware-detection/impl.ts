import type { FunctionService } from '../../../service.ts';
import type { EventGridEvent, InvocationContext } from '@azure/functions';
import { GovNotifyClient, TEAM_EMAIL_ADDRESS } from '@pins/dco-portal-lib/govnotify/gov-notify-client.ts';
import { SCAN_RESULT_ID, WHITELIST_USER_ROLE_ID } from '@pins/dco-portal-database/src/seed/data-static.ts';
import type { PrismaClient } from '@pins/dco-portal-database/src/client/client.ts';

export function buildMalwareDetectionHandler(service: FunctionService) {
	return async (eventGridEvent: EventGridEvent, context: InvocationContext) => {
		const { db, notifyClient } = service;

		if (!eventGridEvent?.data) {
			throw new Error('Received no input');
		}

		const { blobUri, scanResultType } = eventGridEvent.data;
		const decodedBlobUri = decodeURIComponent(blobUri as string);
		const info = getInfoFromBlobURI(decodedBlobUri);

		if (!info) {
			throw new Error(`Not possible to extract info from blob with URI ${decodedBlobUri}`);
		}

		const { blobName, caseReference, documentSubCategoryId, fileName } = info;

		const documentToUpdate = await db.document.findFirst({
			where: {
				fileName,
				subCategoryId: documentSubCategoryId,
				blobName,
				Case: {
					reference: caseReference
				}
			}
		});

		if (!documentToUpdate) {
			throw new Error(`Document not found in database with URI ${decodedBlobUri}`);
		}

		try {
			context.log(`Scan result type is: ${scanResultType}`);
			const scanResult = statusFromScanResult(scanResultType as string);
			db.document.update({
				where: {
					id: documentToUpdate.id
				},
				data: {
					ScanResult: {
						connect: {
							id: scanResult
						}
					}
				}
			});

			if (scanResult === SCAN_RESULT_ID.AFFECTED) {
				await dispatchVirusDetectedEmail(
					db,
					notifyClient as GovNotifyClient,
					caseReference,
					documentToUpdate.uploaderEmail,
					fileName
				);
			}

			context.log(`Document scan complete for document: ${blobUri}`);
		} catch (error) {
			let errorMessage;
			if (error instanceof Error) {
				context.error('Error during malware detection function run: ', error);
				errorMessage = error.message;
			}
			throw new Error('Error during malware detection function run: ' + errorMessage);
		}
	};
}

function statusFromScanResult(scanResult: string): string {
	switch (scanResult) {
		case 'Malicious':
			return 'affected';
		case 'No threats found':
			return 'scanned';
		default:
			throw new Error(`Could not map scan result '${scanResult}' to a document status`);
	}
}

function getInfoFromBlobURI(uri: string) {
	const url = new URL(uri);
	const path = url.pathname.replace(/^\/+/, '');
	const match = path.match(/^(?:dco-portal-documents\/)?([^/]+)\/([^/]+)\/([^/]+)\/(.+)$/);

	if (!match) {
		return null;
	}

	const blobName = match?.[0]?.replace(/^dco-portal-documents\//, '') ?? null;
	const caseReference = match?.[1] ?? null;
	const documentCategoryId = match?.[2] ?? null;
	const documentSubCategoryId = match?.[3] ?? null;
	let fileName: string | null = null;
	if (typeof match?.[4] === 'string' && match[4].length > 0) {
		try {
			fileName = decodeURIComponent(match[4]);
		} catch {
			fileName = null;
		}
	}

	if (caseReference && documentCategoryId && documentSubCategoryId && fileName) {
		return {
			blobName,
			caseReference,
			documentCategoryId,
			documentSubCategoryId,
			fileName
		};
	}
}

async function dispatchVirusDetectedEmail(
	db: PrismaClient,
	notifyClient: GovNotifyClient,
	caseReference: string,
	uploaderEmail: string,
	fileName: string
) {
	const caseData = await db.case.findUnique({
		where: {
			reference: caseReference
		},
		select: {
			Whitelist: {
				where: {
					userRoleId: WHITELIST_USER_ROLE_ID.ADMIN_USER
				},
				select: {
					email: true
				}
			}
		}
	});

	const emails = [...(caseData?.Whitelist.map((whitelistUser) => whitelistUser.email) ?? []), uploaderEmail];

	await Promise.all(
		emails.map((email) =>
			notifyClient?.sendAntiVirusFailedNotification(email, {
				document_name: fileName,
				case_reference_number: caseReference,
				relevant_team_email_address: TEAM_EMAIL_ADDRESS
			})
		)
	);
}
